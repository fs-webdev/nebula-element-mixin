<script>
(function() {
  'use strict';

  window.Nebula = window.Nebula || {}

  const InvalidArgumentError = function(property) {
    return new Error(`The ${property} argument is missing or invalid`)
  }

  const __listeners = Symbol()
  const __debouncers = Symbol()
  const __observers = Symbol()
  const __computed = Symbol()
  const __hash = Symbol()

  const _debounce = Symbol.for('Nebula.ElementMixin.debounce')
  const _listen = Symbol.for('Nebula.ElementMixin.listen')
  const _unlisten = Symbol.for('Nebula.ElementMixin.unlisten')
  const _observe = Symbol.for('Nebula.ElementMixin.observe')
  const _compute = Symbol.for('Nebula.ElementMixin.compute')
  const _fire = Symbol.for('Nebula.ElementMixin.fire')

  /**
   * Class expression factory (mixin) to extend a custom element with utility methods.
   * @param {Object} base - The base class to extend.
   * @return {class} - A class that extends from the base class argument.
   */
  Nebula.ElementMixin = Polymer.dedupingMixin(function(base) {
    return class extends base {

    /**
     * Creates a new instance.
     * @constructor
     */ 
     constructor() {
        super()
        this[__listeners] = new Map()
        this[__computed] = new Map()
        this[__debouncers] = new Map()
        this[__observers] = new Map()
      }

      /**
       * Generates a numeric hash for a string for use as an auto-generated key.
       * @method __hash
       * @param {string} source - The string value to hash.
       * @private
       */
      [__hash](source) {
        if (typeof source !== 'string' && source.length === 0) return

        let hash
        for (let i = 0; i < source.length; i++) {
          let charCode = source.charCodeAt(i)
          hash  = ((hash << 5) - hash) + charCode
          hash |= 0
        }
        
        return Math.abs(hash).toString()
      }

      /**
       * Creates a method observer imperatively for the specified expression.
       * @method _observe
       * @param {string} source - The property expression to observe for changes.
       * @param {function()} callback - The function to invoke when the expression is matched.
       * @protected
      */
      [_observe](source, callback) {
        if (!(typeof source === 'string' && source.length > 0)) throw InvalidArgumentError('source')
        if (typeof callback !== 'function') throw InvalidArgumentError('callback')

        const key = this[__hash](source)
        const exp = `__observe('${key}', ${source})`

        this[__observers].set(key, callback)
        this._createMethodObserver(exp)
      }

      /**
       * Delegate observer method to resolve observer by key and invoke callback.
       * @method __observe
       * @param {string} key - The key for the observer callback to invoke.
       * @param {...*} params - The property change arguments to pass to the observer callback. 
       * @private
       */
      __observe(key, ...params) {
        if (this[__observers].has(key)) {
          let callback = this[__observers].get(key)
          callback.apply(this, params)
        }
      }

      /**
       * Creates a computed method imperatively for the specified properties.
       * @method _compute
       * @param {string} target - The name of the target property to compute.
       * @param {string} source - A property observation expression with computed method dependencies.
       * @param {function()} callback - The callback function to invoke when the source expression is matched.
       * @protected
       */
      [_compute](target, source, callback) {
        if (typeof target !== 'string') throw InvalidArgumentError('target')
        if (!(typeof source === 'string' && source.length > 0)) throw InvalidArgumentError('source')
        if (typeof callback !== 'function') throw InvalidArgumentError('callback')

        const key = this[__hash](source)
        const exp = `__compute('${key}', ${source})`

        this[__computed].set(key, callback)
        this._createComputedProperty(target, exp)
      }

      /**
       * Delegate computed method to resolve computed function by key and invoke callback.
       * @method __compute
       * @param {string} key - The key for the computed property callback to invoke.
       * @param {...*} params - The property change arguments to pass to the computed callback.
       * @private
       */
      __compute(key, ...params) {
        if (this[__computed].has(key)) {
          let callback = this[__computed].get(key)
          return callback.apply(this, params)
        }
      }

      /**
       * Adds an event listener to the specified target element.
       * @method _listen
       * @param {EventTarget} target - The target element of the event listener.
       * @param {string} eventType - The name of the event type to listen to.
       * @param {function()} callback - The callback function to invoke when the event is triggered.
       * @protected
       */
      [_listen](target, eventType, callback) {
        target = target || this
        if (!(typeof eventType === 'string' && eventType.length > 0)) throw InvalidArgumentError('eventType')
        if (typeof callback !== 'function') throw InvalidArgumentError('callback')

        const handler = callback.bind(this)
        if (!this[__listeners].has(target)) this[__listeners].set(target, new Map())
        this[__listeners].get(target).set(eventType, handler)

        target.addEventListener(eventType, handler)
      }

      /**
      * Removes an event listener.
      * @method _unlisten
      * @param {EventTarget} target - The event target to remove the listener from.
      * @param {string} eventType - The name of the event type for the listener to remove.
      * @protected
      */
      [_unlisten](target, eventType) {
        target = target || this
        if (!(typeof eventType === 'string' && eventType.length > 0)) throw InvalidArgumentError('eventType')

        if (this[__listeners].has(target)) {
          if (this[__listeners].get(target).has(eventType)) {
            const handler = this[__listeners].get(target).get(eventType)
            target.removeEventListener(eventType, handler)
          }
        }
      }
      
      /**
      * Collapses multiple function calls into a single invocation within a wait period.
      * @method _debounce
      * @param {string} jobName - The unique name for the debounce function.
      * @param {function()} callback - The function to invoke when the debounce is complete.
      * @protected
      */      
      [_debounce](jobName, callback, delay = 0) {
        if (!(typeof jobName === 'string' && jobName.length > 0)) throw InvalidArgumentError('jobName')
        if (typeof callback !== 'function') throw InvalidArgumentError('callback')

        if (this[__debouncers].has(jobName)) {
          clearTimeout(this[__debouncers].get(jobName))
        }
        this[__debouncers].set(jobName, setTimeout(callback.bind(this), delay))
      }

      /**
       * Fires a custom event.
       * @method _fire
       * @param {string} eventType - The name of the event to fire.
       * @param {*} detail - The value to assign the the custom event detail property.
       * @param {Object} options - The event options.
       * @returns {boolean} The return value is false if event is cancelable and at least one of the event handlers which handled this event called `preventDefault`; otherwise it returns true.
       * @protected 
       */
      [_fire](eventType, detail, options) {
        if (!(typeof eventType === 'string' && eventType.length > 0)) throw InvalidArgumentError('eventType')
        
        return this.dispatchEvent(
          new CustomEvent(eventType, Object.assign({}, {detail: detail}, options))
        )
      }

    }
  })
  
}())
</script>
<!--
@license
Copyright (c) 2017 Ars Nebula LLC.
This code may be used under the terms found in LICENSE.md of this repository.
-->

<script>
(function() {
  'use strict';

  window.Nebula = window.Nebula || {}

  const listeners = Symbol()
  const debouncers = Symbol()
  const observers = Symbol()

  /**
  * `Nebula.ElementMixin` is a set of custom element utility methods.
  *
  * ## Usage
  * 
  * The mixin adds back many of the utility functions provided in Polymer v1 that were removed in Polymer v2 including `listen` and `unlisten`, `fire`, and `debounce`.
  *
  * ### Observe
  *
  * Use the `observe` method to add and remove observers imperatively. Each observer must be given a unique `key`, an array of observation `paths` (which can include wildcards and splices), and a `callback` handler.
  *
  * To observe property effects made during initialization, add them to the constructor. To observe property effects made after initialization, add them to the `ready` lifecycle callback.
  *
  * ```js
  * constructor() {
  *   super()
  *   this.observe('myData', ['myData.*'], this._onDataChanged) 
  * } 
  *
  * ### Listen and Unlisten
  *
  * The Use automatic node finding and the convenience methods listen and unlisten.
  *
  * ```js
  * this.listen(this.$.myButton, 'tap', this._onTap)
  * this.unlisten(this.$.myButton, 'tap')
  * ```
  *
  * The context of the listener callback function is automatically bound to the element, and is invoked with `this` set to the element instance.
  *
  * WARNING: The callback parameter of the `listener` method takes a `function`, NOT a `string` containing the name of the callback handler. This change enables binding to methods with computed function names.
  *
  * ### Debounce
  *
  * Debounce collapses multiple function calls into a single invocation with a specified delay timespan.
  *
  * ```js
  * this.debounce('myJob', function() { console.log('debounce') }, 500)
  * ```
  *
  * The context of the debounce function is automatically bound to the element, and is invoked with `this` set to the element instance.
  *
  *
  * ### Fires
  *
  * The fire method dispatches a `CustomEvent`.
  *
  * ```js
  * this.fire('my-event', {message: 'Hello World'}, {bubbles: true})
  * ```
  *
  * @polymerBehavior
  * @demo demo/index.html
  */
  Nebula.ElementMixin = Polymer.dedupingMixin(function(base) {
    return class extends base {

      constructor() {
        super()
        this[listeners] = new Map()
        this[debouncers] = new Map()
        this[observers] = new Map()
      }

      /**
      * Creates a method observer imperatively for the specified key.
      * To receive property effects during initialization, add observers in the element `constructor`.
      * To defer property effects until after initialization, add observers in the element `ready` callback.
      */
      observe(key, paths, callback) {
        if (!(key)) throw new Error('The observer key is invalid')
        if (!(Array.isArray(paths))) throw new Error('The observer property paths array is invalid')
        if (!(typeof callback === 'function')) throw new Error('The observer callback function is invalid')

        this[observers].set(key, callback)
        this._createMethodObserver(`_observe('${key}',${paths.toString(',')})`)
      }

      /**
      * Delegate observer method to resolve observer by key and invoke callback.
      */
      _observe(key, ...params) {
        if (this[observers].has(key)) {
          let callback = this[observers].get(key)
          callback.apply(this, params)
        }
      }

      /**
      * Adds an event listener to the specified target element.
      * The event listener is automatically bound to the class context.
      */
      listen(target, event, callback) {
        target = target || this
        if (typeof event !== 'string') throw new Error('The event name is invalid')
        if (typeof callback !== 'function') throw new Error('The listener callback is invalid')

        const handler = callback.bind(this)
        if (!this[listeners].has(target)) this[listeners].set(target, new Map())
        this[listeners].get(target).set(event, handler)
        target.addEventListener(event, handler)
      }

      /**
      * Removes an event listener.
      */
      unlisten(target, event) {
        target = target || this
        if (typeof event !== 'string') throw new Error('The event is name is invalid')

        if (this[listeners].has(target)) {
          if (this[listeners].get(target).has(event)) {
            const handler = this[listeners].get(target).get(event)
            target.removeEventListener(event, handler)
          }
        }
      }
      
      /**
      * Collapses multiple function calls into a single invocation within a wait period.
      */      
      debounce(key, callback, delay = 0) {
        if (!key) throw new Error('The debounce key is invalid')
        if (typeof callback !== 'function') throw new Error('The debounce callback is invalid')
        
        if (this[debouncers].has(key)) clearTimeout(this[debouncers].get(key))
        this[debouncers].set(key, setTimeout(callback.bind(this), delay))
      }

      /**
      * Fires a custom event.
      */
      fire(event, detail, options) {
        this.dispatchEvent(
          new CustomEvent(event, Object.assign({}, {detail: detail}, options))
        )
      }

    }
  })
  
}())
</script>